### 1. Какой самый эффективный способ конкатенации строк?

Использование библиотеки *bytes*, а именно структуру *Buffer*. Инициализируем нашу строку как 
*var buffer bytes.Buffer*. Конкатенация происходит посредством вызова метода *WriteString* к нашей 
переменной. Для того чтобы вернуть нашу строку как *string*, после завершения конкатенации воспользуемся 
методом *String()* для нашей переменной *buffer*.

### 2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы - особое определение для какого либо типа. Интерфейсы синтаксически похожи на структуры,
и по факту схожи по цели работы: интерфейс хранит в себе сигнатуры методов. Интерфейсы активно
применяются для разгрузки шаблонного кода, помогают в реализации вложенных методов, а также
для адаптации разных частей кода друг под друга.

### 3. Чем отличаются RWMutex от Mutex?

При взаимодействии с мьютексом выдается одинаковая блокировка *Lock()*, вне зависимости, что необходимо
сделать: записать данные или прочитать. В случае, когда данные необходимо прочитать, логичнее использовать
*RWMutex.RLock()*, что дает сильный прирост производительности, но нужно быть уверенным, что данные будут только
читаться.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

Буферизированные каналы сохраняют получаемые данные в виде кольцевого массива, имеющую определенную логику
с ресивером и сендером. Не буфферизированные каналы же предоставляют лишь доставку от сендера к ресиверу.

### 5. Какой размер у структуры struct{}{}?

Т.к. данная структура не подкреплена теплом с типом данных, ее размер - 0Б. Такую структуру можно
использовать как сигнал в каналах, так как она не занимает памяти.

### 6. Есть ли в Go перегрузка методов или операторов?

Нет, в Go нет поддержки перегрузки методов или операторов, как это сделано
в некоторых других языках программирования, таких как C++ или Java.

Перегрузка методов (или функций) означает возможность иметь несколько функций с одним и тем же именем,
но разными наборами параметров. В языке Go, имена методов (и функций) должны быть уникальными в рамках одного пакета,
и нельзя определять функции с одним и тем же именем и разными параметрами.

### 7.В какой последовательности будут выведены элементы map[int]int?

В Go при итерации по элементам карты (map) 
порядок вывода элементов неопределённый. 
Это означает, что Go не гарантирует порядок, 
в котором будут возвращаться ключи и значения. 
Даже если ключи добавлены в карту в определённом порядке, 
при итерировании порядок может быть произвольным 
и может меняться при каждом запуске программы.

### 8. В чем разница make и new?

Make и new – это встроенные механизмы для выделения памяти. Они используются в разных
ситуациях и имеют свои особенности. new инициализирует нулевое значение для данного типа
и возвращает указатель на этот тип. make используется исключительно для создания и
инициализации срезов, отображений и каналов, возвращает ненулевой экземпляр указанного типа.

### 9. Сколько существует способов задать переменную типа slice или map?

Всего 2 способа:
- Через make, что позволяет создать структуру с изначальной вместимостью и избежать
  излишней работы с памятью (в виде постоянного расширения изначального массива)
- Задав в обыкновенном виде: *var a = map[string]bool{}*. Данный способ является плохим тоном
  по причине описанной в П.1: после расширения исходного массива, будет пересоздаваться новый массив
  с удвоенной памятью, что так же может повлечь за собой пустые элементы.

### 10. Что выведет данная программа и почему?

Программа, представленная на листинге выведет:

1

1

Так как в функции обновления *update(p *int)* производится не перезапись исходной переменной по указателю,
а локальное изменение. Для выполнения задумки в виде перезаписи переменной по указателю необходимо записать:
**p = b*, а не *p = &b*.

### 11. Что выведет данная программа и почему?

На листинге в задании 11 представлен код. Сразу очевидна ошибка компиляции в виде дэдлока спящих горутин.
Причина - передача в горутину WaitGroup`а не по указателю. Из-за этого добалвенные в ожидание (5) "ВэйтГруппы"
не завершаются. Для исправления ситуации в горутину стоит передавать не *wg*, а *&wg*, а параметром указывать
wg *sync.WaitGroup

### 12. Что выведет данная программа и почему?

Программа выведет 0, так как в области видимости условной конструкции реинициализируется перменная *n*,
что не изменяет исходную переменную, а создает переменную с таким же названием но в локальной области, и
как раз эта локальная переменная инкрементируется. Для исправления ситуации достаточно убрать *:* в выполнении
условия, так наша переменная будет изменятся, а не реинициализироваться.

### 13. Что выведет данная программа и почему?

Код из листинга к задаче 13 выведет *{100, 2, 3, 4, 5}* так как при присваивании нулевому элементу значение
идет обращение по адресу к исходному слайсу (слайс представляет собой ссылку на статический массив). Цифра 6
не добавляется в исходный массив потому, что операция *append* пересоздает такой же слайс, следственно после такой
операции функция переходит на работу с вновь созданным локальным слайсом, а не с исходным.

### 14. Что выведет данная программа и почему?

Данная программа выведет два разных массива: *[b b a]* и *[a a]*, так как после операции *append* создается
новый слайс, дальнейшая локальная работа происходит именно с ним. Исходный же слайс остется неизменным так как
к нему нету обращений, опять же операции в анонимной функции представлены для локального и вновь созданного
слайса.

