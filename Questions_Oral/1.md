### 1. Какой самый эффективный способ конкатенации строк?

Использование библиотеки bytes, а именно структуру Buffer. Инициализируем нашу строку как 
*var buffer bytes.Buffer. Конкатенация происходит посредством вызова метода WriteString к нашей 
переменной. Для того чтобы вернуть нашу строку как string, после завершения конкатенации воспользуемся 
методом String() для нашей переменной buffer.

### 2. Что такое интерфейсы, как они применяются в Go?

Интерфейс в Go — это своего рода контракт между пользователем и реализацией. 
Он определяет набор методов, которые должны быть реализованы любым типом, 
претендующим на соответствие этому интерфейсу.

В Go используется утиная типизация, 
что означает, что если структура поддерживает набор методов, 
определенных в интерфейсе, 
она автоматически считается реализацией этого интерфейса, без явного указания. 
Таким образом, если тип поддерживает методы интерфейса, 
он автоматически его реализует.

Пустой интерфейс (interface{}) играет особую роль, 
особенно до появления дженериков. 
Поскольку пустой интерфейс не определяет методов, 
он может содержать значения любого типа. 
Это позволяло передавать и хранить в нем любые объекты, 
а затем приводить их к нужному типу с помощью приведения 
(type assertion), проверяя, удалось ли приведение (успешное или нет). 
Такой подход был полезен, например, при работе с ненормированными данными, как JSON.

Даже с дженериками пустой интерфейс полезен, когда структура данных может изменяться, 
так как дженерики не всегда решают проблему с новыми полями.

### 3. Чем отличаются RWMutex от Mutex?

Mutex - это объект, который может находиться
в 2 состояниях.
- заблокированном
- разблокированном
  Алгоритм работы с Mutex обычно такой:
1)  В потоке А вызывается метод М, модифицирующий
    данные
2) Внутри М блокируется Mutex
3) Выполняется остальная часть функции
4) Mutex разблокируется

Когда приложение имеет высокую частоту операций
чтения и записи в какой-то области памяти
использование обычного Mutex заметно
снижает производительность.

Частично решить проблему с накладными
расходами в связи с блокировками
поможет RWMutex.
Это все тот же мьютекс только он позволяет получать
эксклюзивные блокировки отдельно на чтение
и отдельно на запись.

RWMutex может стать неплохой оптимизацией
в местах где используется одна и та же блокировка
и для чтения, и для записи данных

### 4. Чем отличаются буферизированные и не буферизированные каналы?

Чтобы разработчику было проще решать задачу синхронизации горутин,
в языке есть инструмент - каналы.
Каналы это переменные специального типа
которые позволяют делать над ними операции
чтения и записи из разных горутин
и не беспокоиться о конкурентном доступе к ним.

По умолчанию операции чтения и записи
блокируют текущий поток за счет чего и обеспечивается асинхронность без явных блоков.

Направление стрелки соответствует направлению движения данных <-.

Каналы могут быть буферизированными, иными словами иметь емкость.

Это значит, что запись в канал будет блокирующей
только если в канал будет записано N элементов, то есть наша емкость.

Чтение будет заблокировано только если канал пуст.

Такие свойства каналов буферизированных каналов могут быть полезны,
поскольку блокировка при каждой записи или чтении не всегда удобно.
Как и с не буферизированными каналами пользоваться стоит осторожно,
если из канала нигде не производится чтение и он переполняется,
происходит взаимная блокировка потоков, которую нельзя разрешить.
Такое явление называется Deadlock.

### 5. Какой размер у структуры struct{}{}?

Т.к. данная структура не подкреплена теплом с типом данных, ее размер - 0Б. Такую структуру можно
использовать как сигнал в каналах, так как она не занимает памяти.

### 6. Есть ли в Go перегрузка методов или операторов?

Нет, в Go нет поддержки перегрузки методов или операторов, как это сделано
в некоторых других языках программирования, таких как C++ или Java.

Перегрузка методов (или функций) означает возможность иметь несколько функций с одним и тем же именем,
но разными наборами параметров. В языке Go, имена методов (и функций) должны быть уникальными в рамках одного пакета,
и нельзя определять функции с одним и тем же именем и разными параметрами.

### 7.В какой последовательности будут выведены элементы map[int]int?

В Go при итерации по элементам карты (map) 
порядок вывода элементов неопределённый. 
Это означает, что Go не гарантирует порядок, 
в котором будут возвращаться ключи и значения. 
Даже если ключи добавлены в карту в определённом порядке, 
при итерировании порядок может быть произвольным 
и может меняться при каждом запуске программы.

### 8. В чем разница make и new?

Make и new – это встроенные механизмы для выделения памяти. Они используются в разных
ситуациях и имеют свои особенности. new инициализирует нулевое значение для данного типа
и возвращает указатель на этот тип. make используется исключительно для создания и
инициализации срезов, отображений и каналов, возвращает ненулевой экземпляр указанного типа.

### 9. Сколько существует способов задать переменную типа slice или map?

Всего 2 способа:
- Через make, что позволяет создать структуру с изначальной вместимостью и избежать
  излишней работы с памятью (в виде постоянного расширения изначального массива)
- Задав в обыкновенном виде: *var a = map[string]bool{}*. Данный способ является плохим тоном
  по причине описанной в П.1: после расширения исходного массива, будет пересоздаваться новый массив
  с удвоенной памятью, что так же может повлечь за собой пустые элементы.

### 10. Что выведет данная программа и почему?

Программа, представленная на листинге выведет:

1

1

Так как в функции обновления *update(p *int)* производится не перезапись исходной переменной по указателю,
а локальное изменение. Для выполнения задумки в виде перезаписи переменной по указателю необходимо записать:
**p = b*, а не *p = &b*.

### 11. Что выведет данная программа и почему?

На листинге в задании 11 представлен код. Сразу очевидна ошибка компиляции в виде дэдлока спящих горутин.
Причина - передача в горутину WaitGroup`а не по указателю. Из-за этого добалвенные в ожидание (5) "ВэйтГруппы"
не завершаются. Для исправления ситуации в горутину стоит передавать не *wg*, а *&wg*, а параметром указывать
wg *sync.WaitGroup

### 12. Что выведет данная программа и почему?

Программа выведет 0, так как в области видимости условной конструкции реинициализируется перменная *n*,
что не изменяет исходную переменную, а создает переменную с таким же названием но в локальной области, и
как раз эта локальная переменная инкрементируется. Для исправления ситуации достаточно убрать *:* в выполнении
условия, так наша переменная будет изменятся, а не реинициализироваться.

### 13. Что выведет данная программа и почему?

Код из листинга к задаче 13 выведет *{100, 2, 3, 4, 5}* так как при присваивании нулевому элементу значение
идет обращение по адресу к исходному слайсу (слайс представляет собой ссылку на статический массив). Цифра 6
не добавляется в исходный массив потому, что операция *append* пересоздает такой же слайс, следственно после такой
операции функция переходит на работу с вновь созданным локальным слайсом, а не с исходным.

### 14. Что выведет данная программа и почему?

Данная программа выведет два разных массива: *[b b a]* и *[a a]*, так как после операции *append* создается
новый слайс, дальнейшая локальная работа происходит именно с ним. Исходный же слайс остется неизменным так как
к нему нету обращений, опять же операции в анонимной функции представлены для локального и вновь созданного
слайса.

