package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

/*
	Реализовать все возможные способы остановки выполнения горутины.
*/

func main() {
	// Горутина завершается с помощью контекста (отмена операции)
	// Аналогия пульт - телевизор
	// Горутины которые слушают контекст остановят работу
	ctx, stop := context.WithCancel(context.Background())

	go func() {
		for {
			select {
			case <-ctx.Done():
				fmt.Println("Goroutine 1 is killed")
				return
			default:
				fmt.Println("Goroutine 1 is running")
				time.Sleep(1 * time.Second)
			}
		}
	}()

	time.Sleep(3 * time.Second)
	stop()

	// Горутина завершается через канал
	// В Go каналы часто используются для общения между горутинами
	// горутины регулярно проверяют, пришло ли что-то в этот канал.
	// Как только вы отправляете в канал специальный сигнал
	// (например, закрываете канал или отправляете специальное значение),
	// горутины "узнают" об этом и могут корректно завершить свою работу

	doneChan := make(chan struct{})

	go func() {
		for {
			select {
			case <-doneChan:
				fmt.Println("Goroutine 2 is killed")
				return
			default:
				fmt.Println("Goroutine 2 is running")
				time.Sleep(1 * time.Second)
			}
		}
	}()

	time.Sleep(3 * time.Second)
	close(doneChan) // Закрываем канал для отправки сигнала о завершении

	// Через WaitGroup
	wg := sync.WaitGroup{}
	wg.Add(1)

	go func() {
		for i := 0; i < 3; i++ {
			fmt.Printf("i am i: %d\n", i)
			time.Sleep(1 * time.Second)
		}
		wg.Done()
	}()

	wg.Wait()
}

/*
	С помощью контекста (context.Context): Создается контекст, который можно "отменить" для остановки горутин, ожидающих сигнала из этого контекста.
	С использованием каналов: Горутины проверяют канал на наличие сигнала и завершают свою работу при его получении.
	С помощью sync.WaitGroup: Используется для ожидания завершения работы нескольких горутин. Горутины сами сообщают о своём завершении.
	Таймеры и тикеры (time.Timer и time.Ticker): Горутины могут реагировать на сигналы таймеров для контроля времени своего выполнения.
	Автономное завершение: Горутина завершается самостоятельно после выполнения своей задачи.
*/

/*
	sync.WaitGroup - это механизм в Go, который позволяет одной горутине ожидать завершения работы других горутин.

	Представьте, что вы - учитель, ведущий занятие с группой студентов (горутинами).
	Вы хотите уйти домой, но только после того, как все студенты закончат свои задачи.
	Вы используете список (это WaitGroup), чтобы отметить каждого студента,
	когда он начинает работу, и чтобы стереть его имя, когда он закончит.
	Как только список станет пустым (все горутины завершили свою работу), вы можете уйти.

	В коде это работает так:

	Вы создаете WaitGroup и используете метод Add, чтобы увеличить счетчик на количество работающих горутин.
	Каждая горутина, когда заканчивает свою работу, вызывает метод Done этой группы, что уменьшает счетчик на единицу.
	Главная горутина (в вашем случае, учитель) использует метод Wait у WaitGroup.
	Этот метод блокирует горутину до тех пор, пока счетчик не станет равен нулю, то есть пока все другие горутины не завершат свою работу.
*/
